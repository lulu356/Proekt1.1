Иногда возникает необходимость создать один и тот же метод, но с разным набором параметров. И в зависимости от имеющихся параметров применять определенную версию метода. Такая возможность еще называется перегрузкой методов (method overloading).

И в языке C# мы можем создавать в классе несколько методов с одним и тем же именем, но разной сигнатурой. Что такое сигнатура? Сигнатура складывается из следующих аспектов:

Имя метода

Количество параметров

Типы параметров

Порядок параметров

Модификаторы параметров

Но названия параметров в сигнатуру НЕ входят. Например, возьмем следующий метод:

1
2
3
4
public int Sum(int x, int y) 
{ 
    return x + y;
}
У данного метода сигнатура будет выглядеть так: Sum(int, int)

И перегрузка метода как раз заключается в том, что методы имеют разную сигнатуру, в которой совпадает только название метода. То есть методы должны отличаться по:

Количеству параметров

Типу параметров

Порядку параметров

Модификаторам параметров

Например, пусть у нас есть следующий класс:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
class Calculator
{
    public void Add(int a, int b)
    {
        int result = a + b;
        Console.WriteLine($"Result is {result}");
    }
    public void Add(int a, int b, int c)
    {
        int result = a + b + c;
        Console.WriteLine($"Result is {result}");
    }
    public int Add(int a, int b, int c, int d)
    {
        int result = a + b + c + d;
        Console.WriteLine($"Result is {result}");
        return result;
    }
    public void Add(double a, double b)
    {
        double result = a + b;
        Console.WriteLine($"Result is {result}");
    }
}
Здесь представлены четыре разных версии метода Add, то есть определены четыре перегрузки данного метода.

Первые три версии метода отличаются по количеству параметров. Четвертая версия совпадает с первой по количеству параметров, но отличается по их типу. При этом достаточно, чтобы хотя бы один параметр отличался по типу. Поэтому это тоже допустимая перегрузка метода Add.

То есть мы можем представить сигнатуры данных методов следующим образом:

1
2
3
4
Add(int, int)
Add(int, int, int)
Add(int, int, int, int)
Add(double, double)
После определения перегруженных версий мы можем использовать их в программе:

1
2
3
4
5
6
7
8
9
10
11
12
13
class Program
{
    static void Main(string[] args)
    {
        Calculator calc = new Calculator();
        calc.Add(1, 2); // 3
        calc.Add(1, 2, 3); // 6
        calc.Add(1, 2, 3, 4); // 10
        calc.Add(1.4, 2.5); // 3.9
         
        Console.ReadKey();
    }
}
Консольный вывод:

Result is 3
Result is 6
Result is 10
Result is 3.9
Также перегружаемые методы могут отличаться по используемым модификаторам. Например:

1
2
3
4
5
6
7
8
9
10
11
void Increment(ref int val)
{
    val++;
    Console.WriteLine(val);
}
 
void Increment(int val)
{
    val++;
    Console.WriteLine(val);
}
В данном случае обе версии метода Increment имеют одинаковый набор параметров одинакового типа, однако в первом случае параметр имеет модификатор ref. Поэтому обе версии метода будут корректными перегрузками метода Increment.

А отличие методов по возвращаемому типу или по имени параметров не является основанием для перегрузки. Например, возьмем следующий набор методов:

1
2
3
4
5
6
7
8
9
10
11
12
int Sum(int x, int y)
{
    return x + y;
}
int Sum(int number1, int number2)
{
    return x + y;
}
void Sum(int x, int y)
{
    Console.WriteLine(x + y);
}
Сигнатура у всех этих методов будет совпадать:

1
Sum(int, int)
Поэтому данный набор методов не представляет корректные перегрузки метода Sum и работать не будет.